from PySide6.QtCore import QObject, Signal, QTimer, Slot
import numpy as np
from scipy.io import wavfile
from scipy import signal
import time
from pathlib import Path
from functools import wraps

from src.constants import PulseShape, MOD_SCHEME_MAP, BitMappingScheme, ModulationScheme
from src.dataclasses.dataclass_models import (
    BasebandModel, BandpassModel, BitStreamModel,
    ModulationModel, PulseModel, SymbolStreamModel
    )
from src.modules.pulse_shapes import CosineSquarePulse, RectanglePulse, RaisedCosinePulse
from src.modules.bit_mapping import BinaryMapper, GrayMapper, RandomMapper
from src.modules.modulation_schemes import AmpShiftKeying, PhaseShiftKeying
from src.modules.symbol_sequencer import SymbolSequencer
from src.modules.baseband_modulator import BasebandSignalGenerator
from src.modules.quadrature_modulator import QuadratureModulator
from src.modules.audio_player import AudioPlaybackHandler
from src.modules.helper_functions import export_transmitted_signal, add_barker_code


# def profile_method(method):
#     """Decorator to time method execution and print results"""
#     @wraps(method)
#     def wrapper(self, *args, **kwargs):
#         start = time.perf_counter()
#         result = method(self, *args, **kwargs)
#         elapsed = (time.perf_counter() - start) * 1000
#         print(f"⏱️  {method.__name__}: {elapsed:.2f}ms")
#         return result
#     return wrapper


class AppState(QObject):
    """
    Manages the application's state and business logic.
    """
    # Signals to notify the GUI of state changes
    sig_pulse_ready = Signal(PulseModel)
    sig_mod_lut_ready = Signal(ModulationModel)
    sig_baseband_ready = Signal(BasebandModel)
    sig_bandpass_processed = Signal(BandpassModel)


    sig_playback_status_changed = Signal(str)
    sig_start_audio_playback = Signal()
    sig_stop_audio_playback = Signal()

    def __init__(self, initial_values):
        super().__init__()

        #------------------------------------------------------------
        # +++++ INIT PARAMETERS +++++
        #------------------------------------------------------------
        self.FS = initial_values["Fs"]
        self.SYM_RATE = initial_values["sym_rate"]
        self.SPS = self.FS // self.SYM_RATE

        # ---- Default Values for Pulse & Mod Scheme ----
        self.span = initial_values["span"]

        self.audio_handler = AudioPlaybackHandler()
        # self.audio_handler.playback_started.connect(self._on_playback_started)
        # self.audio_handler.playback_finished.connect(self._on_playback_finished)
        # self.audio_handler.playback_error.connect(self._on_playback_error)

        self.map_mod_scheme = MOD_SCHEME_MAP

        # Initialize current Interactive Signals
        self.current_pulse_model: PulseModel = self._init_default_pulse()
        self.current_mod_model: ModulationModel = self._init_default_mod_scheme()
        self.current_bitstream: BitStreamModel
        self.current_symbol_stream: SymbolStreamModel
        self.current_baseband_signal: BasebandModel
        self.current_bandpass_signal: BandpassModel
        self.barker_baseband = None

    def init_barker_preemble(self):
        # 1. Get the current Look-Up Table (Dictionary)
        # Accessing the codebook generated by your ASK/PSK classes
        lut = self.current_mod_model.look_up_table

        # 2. Pick the two most "Distant" symbols for maximum Barker contrast
        # We find the symbols with the minimum and maximum real values
        symbols = list(lut.values())
        s_min = symbols[np.argmin(np.real(symbols))]
        s_max = symbols[np.argmax(np.real(symbols))]

        # 3. Map Barker bits to these specific Complex Symbols
        barker_bits = np.array([1, 1, 1, 0, 0, 1, 0])
        barker_symbols = np.where(barker_bits == 1, s_max, s_min)

        # 4. Generate the "Hidden" Barker Baseband
        # This uses the specific generate() method from your Rectangle/RC pulse classes
        self.barker_baseband = signal.upfirdn(
            h = self.current_pulse_model.data,
            x = barker_symbols,
            up = self.SPS
        )


    def _init_default_pulse(self):

        init_two_ask = RectanglePulse(self.SYM_RATE, self.FS, self.span, roll_off = None)

        pulse_data = init_two_ask.generate() # generate the actual Data

        # Update current pulse signal
        self.current_pulse_model = PulseModel(
            name=f"Rectangle Pulse",
            data=pulse_data,
            fs=self.FS,
            sym_rate=self.SYM_RATE,
            shape=PulseShape.RECTANGLE,
            span=self.span
        )

        self.sig_pulse_ready.emit(self.current_pulse_model)

        return self.current_pulse_model


    def _init_default_mod_scheme(self):

        mapper = BinaryMapper()

        lut_data = AmpShiftKeying(2, mapper=mapper).codebook
        self.current_mod_model = ModulationModel(
            name="Default 2-ASK",
            data=None,
            look_up_table=lut_data,
            cardinality=2,
            mapper=BitMappingScheme.BINARY,
            mod_scheme=ModulationScheme.ASK
        )

        self.sig_mod_lut_ready.emit(self.current_mod_model)
        return self.current_mod_model


    def on_pulse_update(self, pulse_model: PulseModel):
        """
        1. Receives the Signal Dataclass Object with Validation
        2. Update Metadata
        3. Generates the actual data
        4. Informs the rest of the app | send back the object to Main Model
        """
        self.current_pulse_model = pulse_model

        pulse_generators = {
            PulseShape.RECTANGLE: RectanglePulse,
            PulseShape.COSINE_SQUARED: CosineSquarePulse,
            PulseShape.RAISED_COSINE: RaisedCosinePulse,
        }

        # Validate if shape is available
        generator_cls = pulse_generators.get(self.current_pulse_model.shape)
        if not generator_cls:
            print(f"Unknown Pulse Shape: {self.current_pulse_model.shape}")
            return

        # Create Generator Object
        try:
            generator = generator_cls(self.current_pulse_model.sym_rate,
                                      self.current_pulse_model.fs,
                                      self.current_pulse_model.span,
                                      self.current_pulse_model.roll_off)
            pulse_data = generator.generate()  # Generate the actual data
        except Exception as e:
            print(f"Failed to generate pulse: {e}")
            return

        # Update current pulse signal
        self.current_pulse_model = PulseModel(
            name=f"{self.current_pulse_model.shape} Pulse",
            data=pulse_data,
            fs=self.FS,
            sym_rate=self.SYM_RATE,
            shape=self.current_pulse_model.shape,
            span=self.current_pulse_model.span
        )

        # Emit signal to notify GUI
        self.sig_pulse_ready.emit(self.current_pulse_model)

        try:
            if isinstance(self.current_symbol_stream, SymbolStreamModel):
                self.update_baseband_signal()
        except:
            pass


    def on_mod_update(self, mod_model: ModulationModel):
            """Updates the modulation state using Enums and structured Models."""
            # 1. Store the incoming model for context
            self.current_mod_model = mod_model

            # 2. Map Enums to Mapper Classes
            mapper_classes = {
                BitMappingScheme.BINARY: BinaryMapper,
                BitMappingScheme.GRAY: GrayMapper,
                BitMappingScheme.RANDOM: RandomMapper,
            }

            # 3. Map Enums to Modulation Classes
            # (Using the base Enums from constants.py)
            mod_classes = {
                ModulationScheme.AMPLITUDE_SHIFT_KEYING: AmpShiftKeying,
                ModulationScheme.PHASE_SHIFT_KEYING: PhaseShiftKeying,
            }

            # 4. Resolve the logic using Enums
            # We assume the handler in main_model.py sent the correct Enum types
            mapper_cls = mapper_classes.get(mod_model.mapper)
            mod_cls = mod_classes.get(mod_model.mod_scheme)

            if not mapper_cls or not mod_cls:
                print(f"Error: Unsupported mapping ({mod_model.mapper}) "
                      f"or scheme ({mod_model.mod_scheme})")
                return

            # 5. Generate the new Look-Up Table (Codebook)
            try:
                mapper_instance = mapper_cls()
                mod_instance = mod_cls(mod_model.cardinality, mapper=mapper_instance)
                lut_data = mod_instance.codebook
            except Exception as e:
                print(f"Failed to generate Modulation LUT: {e}")
                return

            # 6. Rebuild the ModulationModel with the generated data
            # Note: Using 'ModulationModel' (Class) not 'mod_model' (Instance)
            self.current_mod_model = ModulationModel(
                            name=f"{mod_model.cardinality}-{mod_model.mod_scheme} Model",
                            data=None,
                            look_up_table=lut_data,
                            cardinality=mod_model.cardinality,
                            mapper=mod_model.mapper,
                            mod_scheme=mod_model.mod_scheme
                        )

            # 7. Notify GUI and trigger update chain
            self.sig_mod_lut_ready.emit(self.current_mod_model)

            if hasattr(self, 'current_bitstream'):
                self.update_symbol_stream()


    #@profile_method
    def on_bitstream_update(self, bit_stream_model: BitStreamModel):
        self.current_bitstream = bit_stream_model


        # Trigger the update chain
        self.update_symbol_stream()


    #@profile_method
    def update_symbol_stream(self):
        """Generates a new symbol stream and triggers a baseband signal update."""

        if not hasattr(self, 'current_bitstream') or self.current_bitstream.data is None:
            return

        # Create Symbol Sequence with Symbol Sequencer Module
        symbol_stream_data = SymbolSequencer(self.current_mod_model).map_bits_to_symbols(self.current_bitstream.data)

        self.current_symbol_stream = SymbolStreamModel(
            name="Current Symbol Stream",
            data=symbol_stream_data,
            mod_scheme=self.current_mod_model,
            bit_stream=self.current_bitstream
        )

        # Automatically update the baseband signal after the symbol stream is updated
        self.update_baseband_signal()


    #@profile_method
    def update_baseband_signal(self):
        """Generates a new baseband signal."""

        if not hasattr(self, 'current_symbol_stream'):
            raise AttributeError("Missing 'current_symbol_stream'. Bitstream must be processed first")

        if not hasattr(self, 'current_pulse_model'):
            raise AttributeError("Missing 'current_pulse_model'. Pulse must be initialized.")

        # Init Baseband generator with active Pulse Object
        baseband_gen_obj = BasebandSignalGenerator(self.current_pulse_model)
        # Generate Baseband Signal
        bb_data = baseband_gen_obj.generate_baseband_signal(self.current_symbol_stream)
        bb_data = signal.upfirdn(
            h = self.current_pulse_model.data,
            x = self.current_symbol_stream.data,
            up= self.SPS)
        self.current_baseband_signal = BasebandModel (
            name = "Current Baseband Signal",
            data = bb_data,
            fs = self.FS,
            sym_rate = self.SYM_RATE,
            pulse = self.current_pulse_model,
            symbol_stream = self.current_symbol_stream
        )

        self.sig_baseband_ready.emit(self.current_baseband_signal)



    #@profile_method
    def on_carrier_freq_update(self, updated_bandpass_model):

        self.current_bandpass_signal = updated_bandpass_model

        # Init Barker Preemble
        self.init_barker_preemble()

        self.current_baseband_signal.data = np.concatenate((self.barker_baseband, self.current_baseband_signal.data))

        # IQ Modulation
        iq_data = QuadratureModulator(self.current_bandpass_signal.carrier_freq).modulate(self.current_baseband_signal)

        self.current_bandpass_signal = BandpassModel (
            name = self.current_bandpass_signal.name,
            data = iq_data,
            fs = self.FS,
            sym_rate = self.SYM_RATE,
            baseband_signal = self.current_baseband_signal,
            carrier_freq = self.current_bandpass_signal.carrier_freq
        )

        self.sig_bandpass_processed.emit(self.current_bandpass_signal)


    #@profile_method
    def play_audio(self):
        """
        Plays the real part of the current bandpass signal if it exists.
        """
        if hasattr(self, 'current_bandpass_signal') and self.current_bandpass_signal.data is not None:
            # Audio hardware typically plays real-valued signals.
            # We take the real part of the complex bandpass signal.
            audio_data = np.real(self.current_bandpass_signal.data)
            self.audio_handler.play(audio_data, self.FS)
        else:
            self.sig_playback_status_changed.emit("Error: No signal generated to play.")
        # TODO UI Feedbacks please not in AppState


    @Slot()
    def on_play_btn_pressed(self):
        """ Slot to be connected to the UI's play button. """
        self.play_audio()


    @Slot()
    def on_stop_signal_pressed(self):
        """ Slot to be connected to the UI's stop button. """
        self.audio_handler.stop()


    def clear_signals(self):
        """Clear baseband and bandpass signal data to free memory and prevent orphaned objects."""
        # Delete the actual data objects
        if hasattr(self, 'current_baseband_signal'):
            del self.current_baseband_signal
        if hasattr(self, 'current_bandpass_signal'):
            del self.current_bandpass_signal
        if hasattr(self, 'current_symbolstream'):
            del self.current_symbol_stream
        if hasattr(self, 'current_bitstream'):
            del self.current_bitstream


    @Slot()
    def on_export_path_changed(self, path):
        """ Slot to be connected to the UI's export path change. """
        if not hasattr(self, 'current_bandpass_signal') or self.current_bandpass_signal.data is None:
                print("Error: No bandpass signal available to save.")
                return

        try:
            p = Path(path)

            if p.suffix.lower() != ".wav":
                p = p.with_suffix(".wav")

            file_name = p.name

            file_path = str(p.parent.resolve())

            export_transmitted_signal(self.current_bandpass_signal, file_name, file_path)

        except Exception as e:
            print(f"Error during WAV file export: {e}")

    @Slot()
    def on_export_pulse(self, path):
        # 1. Convert the dataclass to a JSON string
        json_string = self.current_pulse_model.to_json(indent=4)

        # 2. Physically write that string to the file path
        try:
            with open(path, 'w', encoding='utf-8') as f:
                f.write(json_string)
            print(f"File successfully saved to: {path}")
        except Exception as e:
            print(f"Error saving file: {e}")




