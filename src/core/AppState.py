from PySide6.QtCore import QObject, Signal, QTimer, Slot
import numpy as np
from scipy.io import wavfile
from scipy import signal
import time
from pathlib import Path
from functools import wraps

from src.constants import PulseShape, MOD_SCHEME_MAP
from src.dataclasses.dataclass_models import BasebandSignal, BandpassSignal, BitStream, ModSchemeLUT, PulseSignal, SymbolStream
from src.modules.pulse_shapes import CosineSquarePulse, RectanglePulse, RaisedCosinePulse
from src.modules.bit_mapping import BinaryMapper, GrayMapper, RandomMapper
from src.modules.modulation_schemes import AmpShiftKeying, PhaseShiftKeying
from src.modules.symbol_sequencer import SymbolSequencer
from src.modules.baseband_modulator import BasebandSignalGenerator
from src.modules.quadrature_modulator import QuadratureModulator
from src.modules.audio_player import AudioPlaybackHandler
from src.modules.helper_functions import export_transmitted_signal, add_barker_code

from src.constants import DEFAULT_FS, DEFAULT_SPAN


# def profile_method(method):
#     """Decorator to time method execution and print results"""
#     @wraps(method)
#     def wrapper(self, *args, **kwargs):
#         start = time.perf_counter()
#         result = method(self, *args, **kwargs)
#         elapsed = (time.perf_counter() - start) * 1000
#         print(f"⏱️  {method.__name__}: {elapsed:.2f}ms")
#         return result
#     return wrapper


class AppState(QObject):
    """
    Manages the application's state and business logic.
    """
    # Signals to notify the GUI of state changes
    sig_app_config_changed = Signal(dict)
    sig_pulse_changed = Signal(PulseSignal)
    sig_mod_lut_changed = Signal(ModSchemeLUT)
    sig_baseband_changed = Signal(BasebandSignal)
    sig_bandpass_changed = Signal(BandpassSignal)


    sig_playback_status_changed = Signal(str)
    sig_start_audio_playback = Signal()
    sig_stop_audio_playback = Signal()

    def __init__(self, initial_values):
        super().__init__()

        #------------------------------------------------------------
        # +++++ INIT PARAMETERS +++++
        #------------------------------------------------------------
        self.FS = DEFAULT_FS
        self.SYM_RATE = initial_values["sym_rate"]
        self.SPS = self.FS // self.SYM_RATE

        # ---- Default Values for Pulse & Mod Scheme ----
        self.SPAN = DEFAULT_SPAN

        # ---- Bandlimited Interpolation ----
        # self.INTERPOLATION_FACTOR = 10
        # self.INTERNAL_SPS = self.SPS // self.INTERPOLATION_FACTOR
        # self.INTERNAL_FS = self.FS // self.INTERPOLATION_FACTOR

        self.audio_handler = AudioPlaybackHandler()
        # self.audio_handler.playback_started.connect(self._on_playback_started)
        # self.audio_handler.playback_finished.connect(self._on_playback_finished)
        # self.audio_handler.playback_error.connect(self._on_playback_error)

        self.map_mod_scheme = MOD_SCHEME_MAP

        # Initialize current Interactive Signals
        self.current_pulse_signal: PulseSignal = self._init_default_pulse()
        self.current_mod_scheme: ModSchemeLUT = self._init_default_mod_scheme()
        self.current_bitstream: BitStream
        self.current_symbol_stream: SymbolStream
        self.current_baseband_signal: BasebandSignal
        self.current_bandpass_signal: BandpassSignal
        self.barker_baseband = None

    def init_barker_preemble(self):
        # 1. Get the current Look-Up Table (Dictionary)
        # Accessing the codebook generated by your ASK/PSK classes
        lut = self.current_mod_scheme.look_up_table

        # 2. Pick the two most "Distant" symbols for maximum Barker contrast
        # We find the symbols with the minimum and maximum real values
        symbols = list(lut.values())
        s_min = symbols[np.argmin(np.real(symbols))]
        s_max = symbols[np.argmax(np.real(symbols))]

        # 3. Map Barker bits to these specific Complex Symbols
        barker_bits = np.array([1, 1, 1, 0, 0, 1, 0])
        barker_symbols = np.where(barker_bits == 1, s_max, s_min)

        # 4. Generate the "Hidden" Barker Baseband
        # This uses the specific generate() method from your Rectangle/RC pulse classes
        self.barker_baseband = signal.upfirdn(
            h = self.current_pulse_signal.data,
            x = barker_symbols,
            up = self.SPS
        )


    def _init_default_pulse(self):

        init_two_ask = RectanglePulse(self.SYM_RATE, self.FS, self.SPAN, roll_off = None)

        pulse_data = init_two_ask.generate() # generate the actual Data

        # Update current pulse signal
        self.current_pulse_signal = PulseSignal(
            name=f"Rectangle Pulse",
            data=pulse_data,
            fs=self.FS,
            sym_rate=self.SYM_RATE,
            shape=PulseShape.RECTANGLE,
            span=self.SPAN
        )

        self.sig_pulse_changed.emit(self.current_pulse_signal)
        return self.current_pulse_signal


    def _init_default_mod_scheme(self):

        mapper = BinaryMapper()

        lut_data = AmpShiftKeying(2, mapper=mapper).codebook

        self.current_mod_scheme = ModSchemeLUT(
            name=f"2-ASK LUT",
            data=None,
            look_up_table=lut_data,
            cardinality = 2,
            mapper = "Binary",
            mod_scheme="2-ASK",
        )

        self.sig_mod_lut_changed.emit(self.current_mod_scheme)
        return self.current_mod_scheme


    def on_pulse_update(self, partial_data):
        pulse_type = partial_data.get("pulse_type")
        span = partial_data.get("span")
        roll_off = partial_data.get("roll_off", 0.0)  # Default roll-off to 0.0 if not provided

        if pulse_type is None or span is None:
            print("Missing required pulse parameters: 'pulse_type' or 'span'")
            return

        pulse_generators = {
            PulseShape.RECTANGLE: RectanglePulse,
            PulseShape.COSINE_SQUARED: CosineSquarePulse,
            PulseShape.RAISED_COSINE: RaisedCosinePulse,
        }

        # Validate if shape is available
        generator_cls = pulse_generators.get(pulse_type)
        if not generator_cls:
            print(f"Unknown Pulse Shape: {pulse_type}")
            return

        # Create Generator Object
        try:
            generator = generator_cls(self.SYM_RATE, self.FS, span, roll_off)
            pulse_data = generator.generate()  # Generate the actual data
        except Exception as e:
            print(f"Failed to generate pulse: {e}")
            return

        # Update current pulse signal
        self.current_pulse_signal = PulseSignal(
            name=f"{pulse_type} Pulse",
            data=pulse_data,
            fs=self.FS,
            sym_rate=self.SYM_RATE,
            shape=pulse_type,
            span=span
        )

        # Emit signal to notify GUI
        self.sig_pulse_changed.emit(self.current_pulse_signal)

        try:
            if isinstance(self.current_symbol_stream, SymbolStream):
                self.update_baseband_signal()
        except:
            pass


    def on_mod_update(self, partial_data):

        sel_mod_scheme = partial_data.get("mod_scheme")
        sel_mapper = partial_data.get("bit_mapping")

        if sel_mapper == "Binary":
            mapper = BinaryMapper()
        elif sel_mapper == "Gray":
            mapper = GrayMapper()
        elif sel_mapper == "Random":
            mapper = RandomMapper()
        else:
            raise ValueError(f"Unsupported bit mapping: {sel_mapper}")

        if sel_mod_scheme == "2-ASK":
            lut_data = AmpShiftKeying(2, mapper=mapper).codebook
        elif sel_mod_scheme == "4-ASK":
            lut_data = AmpShiftKeying(4, mapper=mapper).codebook
        elif sel_mod_scheme == "8-ASK":
            lut_data = AmpShiftKeying(8, mapper=mapper).codebook
        elif sel_mod_scheme =="2-PSK":
            lut_data = PhaseShiftKeying(2, mapper=mapper).codebook
        elif sel_mod_scheme =="4-PSK":
            lut_data = PhaseShiftKeying(4, mapper=mapper).codebook
        elif sel_mod_scheme =="8-PSK":
            lut_data = PhaseShiftKeying(8, mapper=mapper).codebook
        else:
            raise ValueError(f"Unsupported modulation scheme: {sel_mod_scheme}")

        self.current_mod_scheme = ModSchemeLUT(
            name=f"{sel_mod_scheme} LUT",
            data=None,
            look_up_table=lut_data,
            cardinality = int(sel_mod_scheme.split("-")[0]),
            mapper = sel_mapper,
            mod_scheme=sel_mod_scheme
        )

        self.sig_mod_lut_changed.emit(self.current_mod_scheme)

        if hasattr(self, 'current_bitstream'):
            self.update_symbol_stream()


    #@profile_method
    def on_bitseq_update(self, partial_data):
        bit_stream_str = partial_data.get("bit_seq")

        if not bit_stream_str:
            self.current_bitstream = BitStream(name="Empty Bit Stream", data=np.array([], dtype=np.int8))
            return

        try:
            # Convert String into Numpy Array full of Int
            bit_stream_arr = np.array([int(char) for char in bit_stream_str], dtype=np.int8)
        except (ValueError, TypeError):
            # Handle cases where the string is not valid for conversion
            print(f"Invalid characters in bit sequence: {bit_stream_str}") # TODO CREATE A LOGGING HANDLER
            return

        self.current_bitstream = BitStream(
            name="Current Bit Stream",
            data=bit_stream_arr
        )

        # Trigger the update chain
        self.update_symbol_stream()


    #@profile_method
    def update_symbol_stream(self):
        """Generates a new symbol stream and triggers a baseband signal update."""

        if not hasattr(self, 'current_bitstream') or self.current_bitstream.data is None:
            return


        # Create Symbol Sequence with Symbol Sequencer Module
        symbol_stream_data = SymbolSequencer(self.current_mod_scheme).map_bits_to_symbols(self.current_bitstream.data)

        self.current_symbol_stream = SymbolStream(
            name="Current Symbol Stream",
            data=symbol_stream_data,
            mod_scheme=self.current_mod_scheme,
            bit_stream=self.current_bitstream
        )

        # Automatically update the baseband signal after the symbol stream is updated
        self.update_baseband_signal()


    #@profile_method
    def update_baseband_signal(self):
        """Generates a new baseband signal."""
        if not hasattr(self, 'current_symbol_stream') or not hasattr(self, 'current_pulse_signal'):
            return

        # Init Baseband generator with active Pulse Object
        baseband_gen_obj = BasebandSignalGenerator(self.current_pulse_signal)

        # Generate Baseband Signal
        #bb_data = baseband_gen_obj.generate_baseband_signal(self.current_symbol_stream)

        bb_data = signal.upfirdn(
            h = self.current_pulse_signal.data,
            x = self.current_symbol_stream.data,
            up= self.SPS)

        self.current_baseband_signal = BasebandSignal (
            name = "Current Baseband Signal",
            data = bb_data,
            fs = self.FS,
            sym_rate = self.SYM_RATE,
            pulse = self.current_pulse_signal,
            symbol_stream = self.current_symbol_stream
        )

        self.sig_baseband_changed.emit(self.current_baseband_signal)


    #@profile_method
    def on_carrier_freq_update(self, partial_data):

        carrier_freq = partial_data.get("carrier_freq")
        if carrier_freq is None:
            print("Carrier frequency is missing in the provided data.")
            return
        try:
            carrier_freq = int(carrier_freq)
        except ValueError:
            print(f"Invalid carrier frequency value: {carrier_freq}")
            return

        # Init Barker Preemble
        self.init_barker_preemble()

        self.current_baseband_signal.data = np.concatenate((self.barker_baseband, self.current_baseband_signal.data))

        # IQ Modulation
        iq_data = QuadratureModulator(carrier_freq).modulate(self.current_baseband_signal)

        self.current_bandpass_signal = BandpassSignal (
            name = "Current Bandpass Signal",
            data = iq_data,
            fs = self.FS,
            sym_rate = self.SYM_RATE,
            baseband_signal = self.current_baseband_signal,
            carrier_freq = carrier_freq
        )
        self.sig_bandpass_changed.emit(self.current_bandpass_signal)


    #@profile_method
    def play_audio(self):
        """
        Plays the real part of the current bandpass signal if it exists.
        """
        if hasattr(self, 'current_bandpass_signal') and self.current_bandpass_signal.data is not None:
            # Audio hardware typically plays real-valued signals.
            # We take the real part of the complex bandpass signal.
            audio_data = np.real(self.current_bandpass_signal.data)
            self.audio_handler.play(audio_data, self.FS)
        else:
            self.sig_playback_status_changed.emit("Error: No signal generated to play.")
        # TODO UI Feedbacks please not in AppState


    @Slot()
    def on_play_btn_pressed(self):
        """ Slot to be connected to the UI's play button. """
        self.play_audio()


    @Slot()
    def on_stop_signal_pressed(self):
        """ Slot to be connected to the UI's stop button. """
        self.audio_handler.stop()


    def clear_signals(self):
        """Clear baseband and bandpass signal data to free memory and prevent orphaned objects."""
        # Delete the actual data objects
        if hasattr(self, 'current_baseband_signal'):
            del self.current_baseband_signal
        if hasattr(self, 'current_bandpass_signal'):
            del self.current_bandpass_signal
        if hasattr(self, 'current_symbolstream'):
            del self.current_symbol_stream
        if hasattr(self, 'current_bitstream'):
            del self.current_bitstream


    @Slot()
    def on_export_path_changed(self, path):
        """ Slot to be connected to the UI's export path change. """
        if not hasattr(self, 'current_bandpass_signal') or self.current_bandpass_signal.data is None:
                print("Error: No bandpass signal available to save.")
                return

        try:
            p = Path(path)

            if p.suffix.lower() != ".wav":
                p = p.with_suffix(".wav")

            file_name = p.name

            file_path = str(p.parent.resolve())

            export_transmitted_signal(self.current_bandpass_signal, file_name, file_path)

        except Exception as e:
            print(f"Error during WAV file export: {e}")

    @Slot()
    def on_export_pulse(self, path):
        # 1. Convert the dataclass to a JSON string
        json_string = self.current_pulse_signal.to_json(indent=4)

        # 2. Physically write that string to the file path
        try:
            with open(path, 'w', encoding='utf-8') as f:
                f.write(json_string)
            print(f"File successfully saved to: {path}")
        except Exception as e:
            print(f"Error saving file: {e}")

# TODO Reorga Dataclasses for export
# TODO Frequency Response for Pulse
# TODO Create Start Chirp?

